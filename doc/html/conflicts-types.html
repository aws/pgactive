<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Types of conflict</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto: bdr-list@2ndquadrant.com"><LINK
REL="HOME"
TITLE="BDR 2.0.6 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Multi-master conflicts"
HREF="conflicts.html"><LINK
REL="PREVIOUS"
TITLE="How conflicts happen"
HREF="conflicts-how.html"><LINK
REL="NEXT"
TITLE="Avoiding or tolerating conflicts"
HREF="conflicts-avoidance.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="website-docs.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=ISO-8859-1"><META
NAME="creation"
CONTENT="2023-04-11T13:16:52"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>BDR 2.0.6 Documentation</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="How conflicts happen"
HREF="conflicts-how.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="conflicts.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 9. Multi-master conflicts</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Avoiding or tolerating conflicts"
HREF="conflicts-avoidance.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="CONFLICTS-TYPES"
>9.2. Types of conflict</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONFLICTS-KEY"
>9.2.1. <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> or <TT
CLASS="LITERAL"
>UNIQUE</TT
> conflicts</A
></H2
><P
>    The most common conflicts are row conflicts where two operations affect a
    row with the same key in ways they could not do on a single node. <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> can
    detect most of those and apply last-update-wins conflict handling or invoke
    a user-defined conflict handler.
   </P
><P
>    Row conflicts include:
    <P
></P
></P><UL
><LI
><P
><TT
CLASS="LITERAL"
>INSERT</TT
> vs <TT
CLASS="LITERAL"
>INSERT</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>INSERT</TT
> vs <TT
CLASS="LITERAL"
>UPDATE</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>UPDATE</TT
> vs <TT
CLASS="LITERAL"
>DELETE</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>INSERT</TT
> vs <TT
CLASS="LITERAL"
>DELETE</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>DELETE</TT
> vs <TT
CLASS="LITERAL"
>DELETE</TT
></P
></LI
></UL
><P>
   </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="CONFLICTS-INSERT-INSERT"
>9.2.1.1. INSERT/INSERT conflicts</A
></H3
><P
>     The most common conflict, <TT
CLASS="LITERAL"
>INSERT</TT
> vs
     <TT
CLASS="LITERAL"
>INSERT</TT
>, arises where <TT
CLASS="LITERAL"
>INSERT</TT
>s on two
     different nodes create a tuple with the same <TT
CLASS="LITERAL"
>PRIMARY
     KEY</TT
> values (or the same values for a single
     <TT
CLASS="LITERAL"
>UNIQUE</TT
> constraint if no <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
>
     exists).  <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> handles this by retaining the most recently inserted tuple
     of the two according to the originating host's timestamps unless a
     user-defined conflict handler overrides this.
    </P
><P
>     No special administrator action is required to deal with these conflicts,
     but the user must understand that <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>one of the
     <TT
CLASS="LITERAL"
>INSERT</TT
>ed tuples is effectively discarded on all
     nodes</I
></SPAN
> - there is no data merging done unless a user defined
     conflict handler does it.
    </P
><P
>     Conflict handling is only possible when <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>only one constraint
     is violated by the incoming insert from the remote node</I
></SPAN
>;
     <A
HREF="conflicts-types.html#CONFLICTS-INSERT-UNIQUE-MULTIPLE-INDEX"
>INSERTs that violate multiple UNIQUE constraints</A
> are more
     problematic.
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="CONFLICTS-INSERT-UNIQUE-MULTIPLE-INDEX"
>9.2.1.2. INSERTs that violate multiple UNIQUE constraints</A
></H3
><P
>     An <TT
CLASS="LITERAL"
>INSERT</TT
>/<TT
CLASS="LITERAL"
>INSERT</TT
> conflict
     can violate more than one <TT
CLASS="LITERAL"
>UNIQUE</TT
> constraint
     (of which one might be the <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
>).
    </P
><P
>     <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> can only handle an
     <TT
CLASS="LITERAL"
>INSERT</TT
>/<TT
CLASS="LITERAL"
>INSERT</TT
> conflict on one
     unique constraint (including the <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
>). If a
     new row conflicts with more than one <TT
CLASS="LITERAL"
>UNIQUE</TT
> constraint
     then the apply worker that's trying to apply the change will
     <TT
CLASS="LITERAL"
>ERROR</TT
> out with:
     </P><PRE
CLASS="PROGRAMLISTING"
>     ERROR: multiple unique constraints violated by remotely INSERTed tuple
     </PRE
><P>
     (Older versions would report a <TT
CLASS="LITERAL"
>"diverging uniqueness
     conflict"</TT
> error instead).
    </P
><P
>     In case of such a conflict, you must manually remove the conflicting
     tuple(s) from the local side by <TT
CLASS="LITERAL"
>DELETE</TT
>ing it or by
     <TT
CLASS="LITERAL"
>UPDATE</TT
>ing it so that it no longer conflicts with the
     new remote tuple. There may be more than one conflicting tuple. There is
     not currently any built-in facility to ignore, discard or merge tuples
     that violate more than one local unique constraint.
    </P
><P
>     See also: <A
HREF="conflicts-types.html#CONFLICTS-UPDATE-UNIQUE-MULTIPLE-INDEX"
>UPDATEs that violate multiple UNIQUE constraints</A
>
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="CONFLICTS-UPDATE-UPDATE"
>9.2.1.3. UPDATE/UPDATE conflicts</A
></H3
><P
>     Where two concurrent <TT
CLASS="LITERAL"
>UPDATE</TT
>s on different nodes change
     the same tuple (but not its <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
>), an
     <TT
CLASS="LITERAL"
>UPDATE</TT
>/<TT
CLASS="LITERAL"
>UPDATE</TT
> conflict occurs on
     replay. These are resolved using last-update-wins handling or, if it
     exists, a user-defined conflict handler.
    </P
><P
>     Because a <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> must exist in order to match tuples
     and perform conflict resolution, <TT
CLASS="LITERAL"
>UPDATE</TT
>s are rejected
     on tables without a <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> with:
     </P><PRE
CLASS="PROGRAMLISTING"
>      ERROR: Cannot run UPDATE or DELETE on table (tablename) because it does not have a primary key.
     </PRE
><P>
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="CONFLICTS-UPDATE-PK"
>9.2.1.4. UPDATE conflicts on the PRIMARY KEY</A
></H3
><P
>     <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> cannot currently perform last-update-wins conflict resolution where
     the <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> is changed by an <TT
CLASS="LITERAL"
>UPDATE</TT
>
     operation. It is permissible to update the primary key, but you must
     ensure that no conflict with existing values is possible.
    </P
><P
>     Conflicts on update of the primary key are divergent conflicts that require
     manual operator intervention; see <A
HREF="conflicts-types.html#CONFLICTS-DIVERGENT"
>Divergent conflicts</A
>.
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="CONFLICTS-UPDATE-UNIQUE-MULTIPLE-INDEX"
>9.2.1.5. UPDATEs that violate multiple UNIQUE constraints</A
></H3
><P
>     Like <A
HREF="conflicts-types.html#CONFLICTS-INSERT-UNIQUE-MULTIPLE-INDEX"
>INSERTs that violate multiple UNIQUE constraints</A
>,
     where an incoming <TT
CLASS="LITERAL"
>UPDATE</TT
> violates more than
     one <TT
CLASS="LITERAL"
>UNIQUE</TT
> index (and/or the <TT
CLASS="LITERAL"
>PRIMARY
     KEY</TT
>), <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> cannot apply last-update-wins conflict resolution.
    </P
><P
>     This is a divergent conflict that will require operator intervention;
     see <A
HREF="conflicts-types.html#CONFLICTS-DIVERGENT"
>Divergent conflicts</A
>.
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="CONFLICTS-UPDATE-DELETE"
>9.2.1.6. UPDATE/DELETE conflicts</A
></H3
><P
>     It is possible for one node to <TT
CLASS="LITERAL"
>UPDATE</TT
> a row that
     another node simultaneously <TT
CLASS="LITERAL"
>DELETE</TT
>s. In this case a
     <TT
CLASS="LITERAL"
>UPDATE</TT
>/<TT
CLASS="LITERAL"
>DELETE</TT
> conflict occurs on
     replay. The resolution of this conflict is to discard any
     <TT
CLASS="LITERAL"
>UPDATE</TT
> that arrives after the
     <TT
CLASS="LITERAL"
>DELETE</TT
> unless a user-defined conflict handler specifies
     otherwise.
    </P
><P
>     Because a <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> must exist in order to match tuples
     and perform conflict resolution, <TT
CLASS="LITERAL"
>DELETE</TT
>s are rejected
     on tables without a <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> with:
     </P><PRE
CLASS="PROGRAMLISTING"
>      ERROR: Cannot run UPDATE or DELETE on table (tablename) because it does not have a primary key.
     </PRE
><P>
    </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>      
      
      <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> cannot currently differentiate between
      <TT
CLASS="LITERAL"
>UPDATE</TT
>/<TT
CLASS="LITERAL"
>DELETE</TT
> conflicts and
      <A
HREF="conflicts-types.html#CONFLICTS-INSERT-UPDATE"
>INSERT/UPDATE conflicts</A
>. In both
      cases an <TT
CLASS="LITERAL"
>UPDATE</TT
> arrives that affects a nonexistent
      row. Since <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> is asynchronous and there's no ordering of replay
      between nodes, it can't tell if this is an update to a new row we haven't
      yet received the insert for, or a row we've already replayed a delete
      for. In both cases the resolution is the same - the update is discarded.
     </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="CONFLICTS-INSERT-UPDATE"
>9.2.1.7. INSERT/UPDATE conflicts</A
></H3
><P
>     If one node <TT
CLASS="LITERAL"
>INSERT</TT
>s a row which is then replayed
     to a 2nd node and <TT
CLASS="LITERAL"
>UPDATE</TT
>d there, a 3rd node may
     receive the <TT
CLASS="LITERAL"
>UPDATE</TT
> from the 2nd node before it receives
     the <TT
CLASS="LITERAL"
>INSERT</TT
> from the 1st node. This is an
     <TT
CLASS="LITERAL"
>INSERT</TT
>/<TT
CLASS="LITERAL"
>UPDATE</TT
> conflict.
    </P
><P
>     
     
     Unless a user defined conflict trigger determines otherwise these
     conflicts are handled by discarding the <TT
CLASS="LITERAL"
>UPDATE</TT
>.  This
     can lead to <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>different data on different nodes</I
></SPAN
>. See
     <A
HREF="conflicts-types.html#CONFLICTS-UPDATE-DELETE"
>UPDATE/DELETE conflicts</A
> for details.
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="CONFLICTS-DELETE-DELETE"
>9.2.1.8. DELETE/DELETE conflicts</A
></H3
><P
>     A <TT
CLASS="LITERAL"
>DELETE</TT
>/<TT
CLASS="LITERAL"
>DELETE</TT
> conflict arises
     where two different nodes concurrently delete the same tuple.
    </P
><P
>     This conflict is harmless since both <TT
CLASS="LITERAL"
>DELETE</TT
>s have
     the same effect, so one of them can be safely ignored.
    </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONFLICTS-FOREIGN-KEY"
>9.2.2. Foreign Key Constraint conflicts</A
></H2
><P
>    Conflicts between a remote transaction being applied and existing local data
    can also occur for <TT
CLASS="LITERAL"
>FOREIGN KEY</TT
> constraints. These
    conflicts are usually transient issues that arise from transactions being
    applied in a different order to the order they appeared to occur logically
    on the nodes that originated them.
   </P
><P
>    BDR applies changes with <TT
CLASS="LITERAL"
>session_replication_role = 'replica'</TT
>
    so foreign keys are <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> checked when applying changes. In a
    multi-master environment this can result in FK violations. Most are transient
    and only exist until replication catches up with changes from another node,
    but it's also possible to create dangling FKs because there's no inter-node
    row locking in BDR. This is a necessary consequence of a partition-tolerant
    asynchronous multi-master system, since one node can insert and commit a new
    child row in some FK relationship at the same time another node concurrently
    deletes the parent row. It's recommended that use of FKs be constrained to
    sets of closely related entities that are generally modified from only one node,
    are infrequently modified, or where the modification's concurrency is
    application-mediated.
   </P
><P
>    It's also possible to <TT
CLASS="LITERAL"
>bdr.acquire_global_lock('ddl')</TT
>
    to lock out other nodes from making concurrent changes, but this is a heavyweight
    option and must be done in <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>all</I
></SPAN
> transactions that may modify the
    related tables. So it's best used for rarely modified data where consistency
    is crucial.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONFLICTS-EXCLUSION"
>9.2.3. Exclusion constraint conflicts</A
></H2
><P
>    
    <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> doesn't support exclusion constraints and restricts their creation.
   </P
><DIV
CLASS="IMPORTANT"
><BLOCKQUOTE
CLASS="IMPORTANT"
><P
><B
>Important: </B
>     If an existing stand-alone database is converted to a <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> database then
     all exclusion constraints should be manually dropped.
    </P
></BLOCKQUOTE
></DIV
><P
>    In a distributed asynchronous system it is not possible to ensure that no
    set of rows that violates the constraint exists, because all transactions
    on different nodes are fully isolated. Exclusion constraints would lead to
    replay deadlocks where replay could not progress from any node to any
    other node because of exclusion constraint violations.
   </P
><P
>    If you force <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> to create an exclusion constraint, or you don't drop
    existing ones when converting a standalone database to <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> you should
    expect replication to break. You can get it to progress again by
    removing or altering the local tuple(s) that an incoming remote tuple
    conflicts with so that the remote transaction can be applied.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2392"
>9.2.4. Global data conflicts</A
></H2
><P
>    
    
    Conflicts can also arise where nodes have global (PostgreSQL-system-wide)
    data, like roles, that differs. This can result in operations - mainly
    <ACRONYM
CLASS="ACRONYM"
>DDL</ACRONYM
> - that can be run successfully and committed
    on one node, but then fail to apply to other nodes.
   </P
><P
>    For example, node1 might have a user named
    <TT
CLASS="LITERAL"
>fred</TT
>, but that user was not created on node2.
    <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> does not replicate <TT
CLASS="LITERAL"
>CREATE USER</TT
> (see
    <A
HREF="ddl-replication-statements.html#DDL-CREATE-ROLE"
><I
CLASS="TERM"
><TT
CLASS="VARNAME"
>CREATE ROLE/USER/GROUP</TT
>
       
       
       
      </I
></A
>) so this situation can arise easily.
    If <TT
CLASS="LITERAL"
>fred</TT
> on node1 creates a table, it will
    be replicated with its owner set to <TT
CLASS="LITERAL"
>fred</TT
>.
    When the DDL command is applied to node2 the DDL will fail
    because there is no user named <TT
CLASS="LITERAL"
>fred</TT
>.
    This failure will emit an <TT
CLASS="LITERAL"
>ERROR</TT
> in the
    PostgreSQL logs on node2 and increment
    <A
HREF="catalog-pg-stat-bdr.html"
>bdr.pg_stat_bdr</A
><TT
CLASS="LITERAL"
>.nr_rollbacks</TT
>.
   </P
><P
>    Administrator intervention is required to resolve this conflict
    by creating the user <TT
CLASS="LITERAL"
>fred</TT
> on node2.
    (It need not have the same permissions, but must exist).
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2413"
>9.2.5. Lock conflicts and deadlock aborts</A
></H2
><P
>    Because <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> apply processes operate very like normal user sessions
    they are subject to the usual rules around row and table locking. This
    can sometimes lead to <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> apply processes waiting on locks held
    by user transactions, or even by each other.
   </P
><P
>    Relevant locking includes;
    <P
></P
></P><UL
><LI
><P
>explicit table-level locking (<TT
CLASS="LITERAL"
>LOCK TABLE ...</TT
>) by user sessions</P
></LI
><LI
><P
>explicit row level locking (<TT
CLASS="LITERAL"
>SELECT ... FOR UPDATE/FOR SHARE</TT
>) by user sessions</P
></LI
><LI
><P
>locking from foreign keys</P
></LI
><LI
><P
>implicit locking because of row <TT
CLASS="LITERAL"
>UPDATE</TT
>s, <TT
CLASS="LITERAL"
>INSERT</TT
>s or <TT
CLASS="LITERAL"
>DELETE</TT
>s, either from local activity or apply from other servers</P
></LI
></UL
><P>
   </P
><P
>    It is even possible for a <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> apply process to deadlock with a user
    transaction, where the user transaction is waiting on a lock held
    by the apply process and vice versa. Two apply processes may also
    deadlock with each other. PostgreSQL's deadlock detector will
    step in and terminate one of the problem transactions. If the <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> apply
    worker's process is terminated it will simply retry and generally succeed.
   </P
><P
>    All these issues are transient and generally require no administrator
    action. If an apply process is stuck for a long time behind a lock
    on an idle user session the administrator may choose to terminate
    the user session to get replication flowing again, but this is
    no different to a user holding a long lock that impacts another
    user session.
   </P
><P
>    Use of the <A
HREF="http://www.postgresql.org/docs/current/static/runtime-config-logging.html#GUC-LOG-LOCK-WAITS"
TARGET="_top"
>    log_lock_waits</A
> facility in PostgreSQL can help identify locking
    related replay stalls.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONFLICTS-DIVERGENT"
>9.2.6. Divergent conflicts</A
></H2
><P
>    Divergent conflicts arise when data that should be the same on different
    nodes differs unexpectedly. Divergent conflicts should not occur, but not
    all such conflicts can be reliably prevented at time of writing.
   </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Warning</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>     Changing the <TT
CLASS="LITERAL"
>PRIMARY KEY</TT
> of a row can lead to a
     divergent conflict if another node changes the key of the same row before
     all nodes have replayed the change. Avoid changing primary keys, or
     change them only on one designated node.
     See <A
HREF="conflicts-types.html#CONFLICTS-UPDATE-PK"
>UPDATE conflicts on the PRIMARY KEY</A
>.
    </P
></TD
></TR
></TABLE
></DIV
><P
>    Divergent conflicts involving row data generally require administrator
    action to manually adjust the data on one of the nodes to be consistent
    with the other one while replication is temporarily disabled using <A
HREF="bdr-configuration-variables.html#GUC-BDR-DO-NOT-REPLICATE"
>bdr.do_not_replicate</A
>. Such conflicts should not arise
    so long as <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> is used as documented and settings or functions marked
    as unsafe are avoided.
   </P
><P
>    The administrator must manually resolve such conflicts. Use of the
    advanced options <A
HREF="bdr-configuration-variables.html#GUC-BDR-DO-NOT-REPLICATE"
>bdr.do_not_replicate</A
>,
    <A
HREF="bdr-configuration-variables.html#GUC-BDR-SKIP-DDL-REPLICATION"
>bdr.skip_ddl_replication</A
> and
    <A
HREF="bdr-configuration-variables.html#GUC-BDR-PERMIT-UNSAFE-DDL-COMMANDS"
>bdr.permit_unsafe_ddl_commands</A
> may be required depending
    on the nature of the conflict. However, careless use of these options
    can make things much worse and it isn't possible to give general
    instructions for resolving all possible kinds of conflict.
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="conflicts-how.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="conflicts-avoidance.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>How conflicts happen</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="conflicts.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Avoiding or tolerating conflicts</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>