<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Traditional approaches to sequences in distributed DBs</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto: bdr-list@2ndquadrant.com"><LINK
REL="HOME"
TITLE="BDR 2.0.6 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Global Sequences"
HREF="global-sequences.html"><LINK
REL="PREVIOUS"
TITLE="Global sequence voting"
HREF="global-sequence-voting.html"><LINK
REL="NEXT"
TITLE="BDR 1.0 global sequences"
HREF="global-sequences-bdr10.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="website-docs.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=ISO-8859-1"><META
NAME="creation"
CONTENT="2023-04-11T13:16:52"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>BDR 2.0.6 Documentation</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Global sequence voting"
HREF="global-sequence-voting.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="global-sequences.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 10. Global Sequences</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="BDR 1.0 global sequences"
HREF="global-sequences-bdr10.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="GLOBAL-SEQUENCES-ALTERNATIVES"
>10.7. Traditional approaches to sequences in distributed DBs</A
></H1
><P
>   Global sequences provide a mostly-application-transparent alternative to
   using offset-step sequences or
   <ACRONYM
CLASS="ACRONYM"
>UUID</ACRONYM
>/<ACRONYM
CLASS="ACRONYM"
>GUID</ACRONYM
> keys, but they are not
   without downsides.
  </P
><P
>   BDR users may use any other multimaster-safe sequence/key generation
   strategy. It is not necessary to use global sequences. The approaches
   described below will be superior for many applications' needs, and
   more sophisticated approaches also exist.
  </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Warning</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>    Applications can <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> safely use counter-table based
    approaches relying on <TT
CLASS="LITERAL"
>SELECT ... FOR UPDATE</TT
>, <TT
CLASS="LITERAL"
>UPDATE
    ... RETURNING ...</TT
> etc for sequence generation in BDR. Because BDR is
    asynchronous and doesn't take row locks between nodes, the same values will
    be generated on more than one node. For the same reason the usual
    strategies for "gapless" sequence generation do not work with BDR. In most
    cases the application should coordinate generation of sequences that must
    be gapless from some external source using two-phase commit, or it should
    only generate them on one node in the BDR group.
   </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="GLOBAL-SEQUENCES-ALTERNATIVE-STEPOFFSET"
>10.7.1. Step/offset sequences</A
></H2
><P
>    In offset-step sequences a normal PostgreSQL sequence is used on each node.
    Each sequence increments by the same amount and starts at differing offsets.
    For example with step 1000 node1's sequence generates 1001, 2001, 3001, and
    so on, node 2's generates 1002, 2002, 3002, etc. This scheme works well
    even if the nodes cannot communicate for extended periods, but requires
    that the designer specify a maximum number of nodes when establishing the
    schema and requires per-node configuration. Mistakes can easily lead to
    overlapping sequences.
   </P
><P
>    It is relatively simple to configure this approach with BDR by creating the
    desired sequence on one node like
    </P><PRE
CLASS="PROGRAMLISTING"
>      CREATE TABLE some_table (
        generated_value bigint primary key
      );

      CREATE SEQUENCE some_seq INCREMENT 1000 OWNED BY some_table.generated_value;

      ALTER TABLE some_table ALTER COLUMN generated_value SET DEFAULT nextval('some_seq');
    </PRE
><P>
    ... then on each node calling <CODE
CLASS="FUNCTION"
>setval</CODE
> to give each node a
    different offset starting value, e.g.
    </P><PRE
CLASS="PROGRAMLISTING"
>      -- On node 1
      SELECT setval('some_seq', 1);

      -- On node 2
      SELECT setval('some_seq', 2);

      -- ... etc
  </PRE
><P>
    You should be sure to allow a large enough <TT
CLASS="LITERAL"
>INCREMENT</TT
> to
    leave room for all the nodes you may ever want to add since changing it in
    future is difficult and disruptive.
   </P
><P
>    On BDR-Postgres 9.4, create the sequence with <TT
CLASS="LITERAL"
>USING local</TT
>
    to make sure there's no conflict with any <TT
CLASS="LITERAL"
>default_sequenceam</TT
>
    setting.
   </P
><P
>    If you use bigint values there is no practial concern about key exhaustion
    even if you use offsets of 10000 or more. You'll need hundreds of years
    with hundreds of machines doing millions of inserts per second to have any
    chance of approaching exhaustion.
   </P
><P
>    BDR does not currently offer any automation for configuration of the
    per-node offsets on such step/offset sequences.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="GLOBAL-SEQUENCES-ALTERNATIVE-COMPOSITE"
>10.7.2. Composite keys</A
></H2
><P
>    A variant on step/offset sequences is to use a composite key composed of
    <TT
CLASS="LITERAL"
>PRIMARY KEY (node_number, generated_value)</TT
> where the
    node number is usually obtained from a function that returns a different
    number on each node. Such a function may be created by temporarily
    disabling DDL replication and creating a constant SQL function, or by using
    a one-row table that isn't part of a replication set to store a different
    value in each node.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="GLOBAL-SEQUENCES-ALTERNATIVE-UUID"
>10.7.3. UUIDs</A
></H2
><P
>    <ACRONYM
CLASS="ACRONYM"
>UUID</ACRONYM
> keys instead eschew sequences entirely and
    use 128-bit universal unique identifiers. These are large random
    or pseudorandom values that are large enough that it's nearly
    impossible for the same value to be generated twice. There is
    no need for nodes to have continuous communication when using
    <ACRONYM
CLASS="ACRONYM"
>UUID</ACRONYM
> keys.
   </P
><P
>    In the incredibly unlikely event of a collision, conflict detection will
    choose the newer of the two inserted records to retain. Conflict logging,
    if enabled, will record such an event, but it is
    <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>exceptionally</I
></SPAN
> unlikely to ever occur, since collisions
    only become practically likely after about 2^64 keys have been generated.
   </P
><P
>    The main downside
    of <ACRONYM
CLASS="ACRONYM"
>UUID</ACRONYM
> keys is that they're somewhat space- and
    network-inefficient, consuming more space not only as a primary key, but
    also where referenced in foreign keys and when transmitted on the wire.
    Additionally, not all applications cope well with
    <SPAN
CLASS="APPLICATION"
>UUID</SPAN
> keys.
   </P
><P
>    PostgreSQL has a built-in <TT
CLASS="LITERAL"
>uuid</TT
> data type and the
    <TT
CLASS="LITERAL"
>uuid-ossp</TT
> extension will generate UUIDs, e.g.
    </P><PRE
CLASS="PROGRAMLISTING"
>     CREATE EXTENSION "uuid-ossp";

     SELECT uuid_generate_v4();
    </PRE
><P>
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="global-sequence-voting.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="global-sequences-bdr10.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Global sequence voting</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="global-sequences.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>BDR 1.0 global sequences</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>