<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>BDR: Weakly coupled multi-master replication</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto: bdr-list@2ndquadrant.com"><LINK
REL="HOME"
TITLE="BDR 2.0.6 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="BDR overview"
HREF="overview.html"><LINK
REL="PREVIOUS"
TITLE="Differences between BDR and trigger-based replication"
HREF="bdr-vs-trigger-based.html"><LINK
REL="NEXT"
TITLE="Installation"
HREF="installation.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="website-docs.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=ISO-8859-1"><META
NAME="creation"
CONTENT="2023-04-11T13:16:52"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>BDR 2.0.6 Documentation</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Differences between BDR and trigger-based replication"
HREF="bdr-vs-trigger-based.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="overview.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 1. BDR overview</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Installation"
HREF="installation.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="WEAK-COUPLED-MULTIMASTER"
>1.4. BDR: Weakly coupled multi-master replication</A
></H1
><P
>   When considering multi-master clustering or replication (with BDR
   or another technology) it is important to understand what's involved,
   and that not all multi-master systems are equal.
  </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>    You don't have to use BDR for multi-master. It's quite reasonable
    to write to only one node, using BDR like an improved read-replica
    system. It's also possible to make sure that any given table/schema
    is only written to on one particular node, so no conflicts can arise.
    You still have to consider replication lag, but no more or less than with
    normal hot standbys. It only gets complicated when your application writes
    to the same tables on multiple nodes at once. If you need to do that,
    keep reading.
   </P
><P
>    BDR supports marking nodes as read-only to make this easier, and nodes
    can be set up in synchronous pairs to reduce (but not eliminate) conflicts
    on failover.
   </P
></BLOCKQUOTE
></DIV
><P
>   Some multi-master systems are <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>tightly-coupled</I
></SPAN
>; these
   tend to make all nodes appear to be part of the same virtual database to
   outside clients, complete with cross-node locking, transaction isolation,
   etc. They also often - but not always - use shared storage, where each node
   connects to the same underlying database files over a SAN or similar. This
   makes life easier for application developers who're used to working with
   stand-alone or single-master databases because they can do everything just
   like they did before. Like with anything there's a price, though: a tightly
   coupled multi-master system does not scale out very well, especially for
   writes, and isn't very tolerant of latency, node outages, or network
   partitions.
  </P
><P
>   Other systems are <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>loosely-coupled</I
></SPAN
>. They don't attempt
   to appear like a single seamless virtual database, and applications can see
   some differences depending on which node they are connected to. Most loosely
   coupled systems don't share storage; instead each node has a copy of the whole
   database or a subset of it locally. If they store only a subset of the data they
   may support routing queries to the correct node, or they may expect the application
   to determine which node to find data on. There is generally no global lock
   manager or transaction manager, so transactions on one node aren't affected
   by locks taken on other nodes. Many loosely coupled systems are asynchronous
   and eventually consistent (see: <A
HREF="bdr-concepts.html"
>Concepts</A
>) so changes
   on one node aren't immediately visible on all other nodes at the same time.
   This can make application development more difficult, but in exchange makes
   the system very tolerant of latency between nodes, temporary network
   partitions or node outages, etc, and makes scale-out more efficient.
  </P
><P
>   BDR is a loosely coupled shared-nothing multi-master design.
  </P
><P
>   This is a broad and overly simplified characterisation of replication, but
   it's enough to explain why applications that use BDR for multi-master
   writes need to be aware of the anomalies that can be introduced by
   asynchronous multi-master replication. It should also help illustrate
   that applications get some significant benefits in exchange:
   <P
></P
></P><UL
><LI
><P
>      Applications using BDR are free to write to any node so long as they
      are careful to prevent or cope with conflicts.
     </P
></LI
><LI
><P
>      There is no complex election of a new master if a node goes down or
      network problems arise. There is no wait for failover. Each node is
      always a master and always directly writeable.
     </P
></LI
><LI
><P
>      The application can be geographically distributed so that the app and is
      close to the data and the user for better performance and availability.
      Reads can be satisfied locally.
     </P
></LI
><LI
><P
>      Applications can be partition-tolerant: the application can keep keep
      working even if it loses communication with some or all other nodes, then
      re-sync automatically when connectivity is restored. Loss of a critical
      VPN tunnel or WAN won't bring the entire store or satellite office to a
      halt.
     </P
></LI
></UL
><P>
  </P
><P
>   With the advantages come challenges.
  </P
><P
>   Because BDR replicates asynchronously, not all nodes have the same view of
   the data at any given instant. On a single node it is guaranteed that
   committed transactions' changes become visible immediately to newly started
   transactions (or in <TT
CLASS="LITERAL"
>READ COMMITTED</TT
> mode, statements).
   This isn't true in BDR - if you <TT
CLASS="LITERAL"
>COMMIT</TT
> a transaction
   that changes a row on one node, then <TT
CLASS="LITERAL"
>SELECT</TT
> that row on
   another node, you may well still get the old value. Applications must
   therefore be designed to be tolerant of stale data or to be "sticky" to a
   node, where they prefer read data from the same node they write it to.
   This is also true of applications using PostgreSQL's physical replication
   feature unless it is used in synchronous mode with only one replica, so
   it's a challenge that's far from unique to BDR.
  </P
><P
>   Locking operations are not replicated to other nodes. If you lock a row
   or table in one node the other nodes have no idea it is locked elsewhere.
   Applications that rely on row or table locking for correctness will
   only work correctly if all their writes and locked reads occur on a
   single node. Applications might rely on locking explicitly via
   <TT
CLASS="LITERAL"
>LOCK TABLE</TT
> or
   <TT
CLASS="LITERAL"
>SELECT ... FOR UPDATE / SHARE</TT
>, but most applications
   rely on it implicitly via <TT
CLASS="LITERAL"
>UPDATE</TT
> and
   <TT
CLASS="LITERAL"
>DELETE</TT
> row-locking, so the absence of explicit locking
   does not mean an app is automatically multi-master safe.
  </P
><P
>   Because of asynchronous replication and the lack of global locking,
   it is possible for transactions on different nodes to perform actions
   that could not happen if both transactions ran on a single node.
   These are called <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>conflicts</I
></SPAN
> and are discussed in detail
   separately; see <A
HREF="conflicts.html"
>Multi-master conflicts</A
>. BDR can resolve
   conflicts using a simple last-update-wins strategy or using user-defined
   conflict handlers. Either way the application design needs to consider
   that conflicts may occur, and where possible minimise them. Na&iuml;ive
   applications that ignore the the possibility of conflicts when writing
   to multiple masters may suffer from lost-updates and other undesirable
   data anomalies.
  </P
><P
>   BDR provides some tools to help make application design easier.  The most
   important is <A
HREF="global-sequences.html"
>Global sequences</A
>, which provide a
   BDR-group-wide generator of unique values for use in synthetic keys.
   Others are discussed in the <A
HREF="conflicts.html"
>Multi-master conflicts</A
> section.
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="bdr-vs-trigger-based.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="installation.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Differences between BDR and trigger-based replication</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="overview.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Installation</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>