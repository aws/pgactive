<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Executing DDL on BDR systems</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto: bdr-list@2ndquadrant.com"><LINK
REL="HOME"
TITLE="BDR 2.0.6 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="DDL Replication"
HREF="ddl-replication.html"><LINK
REL="PREVIOUS"
TITLE="DDL Replication"
HREF="ddl-replication.html"><LINK
REL="NEXT"
TITLE="Statement specific DDL replication concerns"
HREF="ddl-replication-statements.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="website-docs.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=ISO-8859-1"><META
NAME="creation"
CONTENT="2023-04-11T13:16:52"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>BDR 2.0.6 Documentation</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="DDL Replication"
HREF="ddl-replication.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="ddl-replication.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 8. DDL Replication</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Statement specific DDL replication concerns"
HREF="ddl-replication-statements.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="DDL-REPLICATION-ADVICE"
>8.1. Executing DDL on BDR systems</A
></H1
><P
>   A BDR group is not the same as a standalone PostgreSQL server. It
   is based on asynchronous multi-master replication without a central
   locking and transaction co-ordinator. This has important implications
   when executing DDL.
  </P
><P
>   BDR has to temporarily transform into a synchronous cluster to run DDL, so
   it has to ensure all nodes are up and fully in sync.
  </P
><P
>   To safely manipulate the database schema in an asynchronous
   multimaster setup, all pending changes have to be replicated first.
   Otherwise it is possible that a row being replicated contains data
   for a row that has been dropped, or has no data for a row that is
   marked <TT
CLASS="LITERAL"
>NOT NULL</TT
>. More complex cases also exist.  To handle
   this problem, <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
> acquires a so-called <A
HREF="ddl-replication-advice.html#DDL-REPLICATION-LOCKING"
>DDL lock</A
> the first time in a
   transaction where schema changes are made.
  </P
><P
>   Acquiring the global DDL lock requires contacting all nodes in a BDR
   group, asking them to replicate all pending changes, and prevent
   further changes from being made. Once all nodes are fully caught up,
   the originator of the DDL lock is free to perform schema changes
   and replicate them to the other nodes.  <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>While the global DDL lock
   is held by a node, no nodes may perform any DDL or make any changes to
   rows</I
></SPAN
>.
  </P
><P
>   This means that schema changes, unlike with data changes, can
   only be performed while all configured nodes are reachable and keeping
   up reasonably well with the current write rate. If DDL absolutely must
   be performed while a node is down, it has to be removed from
   the configuration (using <A
HREF="functions-node-mgmt.html#FUNCTION-BDR-PART-BY-NODE-NAMES"
>bdr.bdr_part_by_node_names</A
>)
   first. (Once removed, a node cannot be added back; it must be decomissioned
   and a new node joined in its place.)
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DDL-REPLICATION-LOCKING"
>8.1.1. The DDL lock</A
></H2
><P
>     DDL is a heavier weight operation than on standalone
     PostgreSQL. Performing DDL on any node will acquire a "global DDL lock". 
     The global DDL lock may also be acquired manually with
     <A
HREF="functions-node-mgmt.html#FUNCTION-BDR-ACQUIRE-GLOBAL-LOCK"
>bdr.acquire_global_lock</A
>.
    </P
><P
>     This causes new transactions that attempt write operations <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>on
     any node except the node that acquired the lock</I
></SPAN
> to pause
     (block) until the DDL lock is released or canceled.  Existing write
     transactions will be given a grace period (controlled by <A
HREF="bdr-configuration-variables.html#GUC-BDR-MAX-DDL-LOCK-DELAY"
>bdr.max_ddl_lock_delay</A
>) to complete and aborted (canceled)
     if they don't complete within the grace period, with the error:
     </P><PRE
CLASS="PROGRAMLISTING"
>FATAL:  terminating connection due to conflict with recovery
DETAIL:  User was holding a relation lock for too long.
     </PRE
><P>
    </P
><P
>     BDR's DDL write lock does not affect writes on the node that acquired it,
     only the other nodes in the BDR group.  The node running the DDL can
     continue to execute DML normally so long as the regular PostgreSQL locks
     taken by its DDL operations permit.  However, concurrent <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>DDL</I
></SPAN
>
     in another transaction on the same node is still not permitted and will
     fail immediately with a DDL lock error.
    </P
><P
>     Newly starting write operations on other nodes continue to be blocked
     until the DDL operation has replicated to all nodes, been applied, and all
     nodes have confirmed to the DDL originator that the changes have been
     applied. Or until the transaction performing the DDL is canceled (aborted)
     by the user or administrator. <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>All writes will be blocked, even
     if it does not affect the objects the currently in-progress DDL is
     modifying.</I
></SPAN
>
    </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>      See <A
HREF="technotes-ddl-locking.html"
>DDL locking details</A
> for additional details on why
      DDL locking is required and how it's done.
     </P
></BLOCKQUOTE
></DIV
><P
>     While <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>any</I
></SPAN
> transaction on any node holds the DDL lock,
     all DDL from any other transaction on any node will immediately
     <TT
CLASS="LITERAL"
>ERROR</TT
> with an error like:
     </P><PRE
CLASS="PROGRAMLISTING"
>ERROR:  database is locked against ddl by another node
HINT:  Node (6313760193895071967,1,16385) in the cluster is already performing DDL
     </PRE
><P>
     There is no grace period for conflicting DDL (schema changes), only DML (row
     writes).
    </P
><P
>     If the transaction holding the DDL lock is taking too long to complete,
     or the DDL lock acquisition is getting stuck because of replication
     delays or down nodes, you can cancel the transaction that's acquiring the
     lock. Just <CODE
CLASS="FUNCTION"
>pg_terminate_backend()</CODE
> the backend
     that's taking/holding the DDL lock. It's all crash-safe.
    </P
><P
>	 If the node that holds the DDL lock goes down permanently while holding
	 the DDL lock, parting the node with <A
HREF="functions-node-mgmt.html#FUNCTION-BDR-PART-BY-NODE-NAMES"
>	 <CODE
CLASS="FUNCTION"
>bdr.bdr_part_by_node_names()</CODE
></A
> will release the lock on
	 other nodes.
	</P
><P
>	 You cannot see the global DDL lock in the <TT
CLASS="FILENAME"
>pg_locks</TT
>
	 view, as it is not implemented using a heavyweight lock. See
	 <A
HREF="monitoring.html"
>Monitoring</A
> for guidance on monitoring BDR,
	 including DDL locking. The <A
HREF="catalog-bdr-locks.html"
>bdr.bdr_locks</A
> view
  provides diagnostic information on lock state.
	</P
><P
>	 BDR 2.0 allows some DDL that doesn't affect table structure to proceed
	 without blocking concurrent writes, only other DDL. See <A
HREF="ddl-replication-statements.html"
>Statement specific DDL replication concerns</A
> for details. Most DDL still requires
	 a full write lock.
	</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DDL-REPLICATION-SAFETY"
>8.1.2. Minimising the impact of DDL</A
></H2
><P
>     To minimise the impact of DDL, transactions performing DDL should be short,
     should not be combined with lots of row changes, and should avoid long
     running foreign key or other constraint re-checks.
    </P
><P
>	 Multiple DDL statements  should generally be bunched into a transaction
	 rather than fired as individual statements, so the DDL lock only has to be
	 taken once.
	</P
><P
>     If DDL is holding the system up for too long, it is possible and safe to
     cancel the DDL on the originating node like you would cancel any other
     statement, e.g. with <TT
CLASS="LITERAL"
>Control-C</TT
> in
     <SPAN
CLASS="APPLICATION"
>psql</SPAN
> or with
     <CODE
CLASS="FUNCTION"
>pg_cancel_backend</CODE
>.
    </P
><P
>     Once the DDL operation has committed on the originating node, you cannot
     cancel or abort it. You must wait for it to apply successfully on all
     other nodes and for them to replay confirmation. This is why it is important
     to keep DDL transactions short and fast.
    </P
><P
>     Because DDL is disruptive in <SPAN
CLASS="PRODUCTNAME"
>BDR</SPAN
>, it's possible to configure the system
     so that transactions can't do DDL
     that requires a heavy global lock by default. This is controlled
     by the <A
HREF="bdr-configuration-variables.html#GUC-BDR-PERMIT-DDL-LOCKING"
>bdr.permit_ddl_locking</A
> setting. If
     set to <TT
CLASS="LITERAL"
>false</TT
>, any command that would
     acquire the global DDL lock is rejected with an
     <TT
CLASS="LITERAL"
>ERROR</TT
> instead. This helps prevent unintended global
     DDL lock acquisitions. You can make this the default for a database,
     user or group with
     </P><PRE
CLASS="PROGRAMLISTING"
> ALTER ROLE username SET bdr.permit_ddl_locking = false;
     </PRE
><P>
     or
     </P><PRE
CLASS="PROGRAMLISTING"
> ALTER DATABASE dbname SET bdr.permit_ddl_locking = false;
     </PRE
><P>
     or set it globally in <TT
CLASS="FILENAME"
>postgresql.conf</TT
>. Then
     when you intend to perform disruptive DDL, explicitly permit it:
     </P><PRE
CLASS="PROGRAMLISTING"
>BEGIN;
SET LOCAL bdr.permit_ddl_locking = true;
-- Do your schema changes here
COMMIT;
     </PRE
><P>
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="ddl-replication.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="ddl-replication-statements.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>DDL Replication</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ddl-replication.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Statement specific DDL replication concerns</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>