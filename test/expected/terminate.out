-- We're one instance with two databases so we should
-- have two walsenders and two apply workers.
SELECT bdr.bdr_replicate_ddl_command($DDL$
CREATE FUNCTION public.wait_for_nwalsenders(nsenders integer)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  WHILE (SELECT count(1) FROM pg_stat_get_wal_senders() s) != nsenders
  LOOP
    PERFORM pg_sleep(0.2);
    PERFORM pg_stat_clear_snapshot();
  END LOOP;
END;
$$;
$DDL$);
 bdr_replicate_ddl_command 
---------------------------
 
(1 row)

SELECT bdr.bdr_replicate_ddl_command($DDL$
CREATE FUNCTION public.wait_for_nworkers(nsenders integer)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  WHILE (SELECT count(1) FROM pg_stat_activity WHERE application_name LIKE 'node%:apply') != nsenders
  LOOP
    PERFORM pg_sleep(0.2);
    PERFORM pg_stat_clear_snapshot();
  END LOOP;
END;
$$;
$DDL$);
 bdr_replicate_ddl_command 
---------------------------
 
(1 row)

SELECT wait_for_nwalsenders(2);
 wait_for_nwalsenders 
----------------------
 
(1 row)

SELECT wait_for_nworkers(2);
 wait_for_nworkers 
-------------------
 
(1 row)

BEGIN; SET LOCAL bdr.skip_ddl_replication = true; SELECT bdr._bdr_pause_worker_management_private(true); COMMIT;
 _bdr_pause_worker_management_private 
--------------------------------------
 
(1 row)

-- We're one instance with two databases so we should have two apply workers
SELECT COUNT(*) = 2 AS ok FROM bdr.bdr_get_workers_info() WHERE worker_type = 'apply';
 ok 
----
 t
(1 row)

-- Kill all apply workers except our own
SELECT n.node_name, bdr.bdr_terminate_workers(node_sysid, node_timeline, node_dboid, 'apply')
  FROM bdr.bdr_nodes n
  WHERE (node_sysid, node_timeline, node_dboid) <> bdr.bdr_get_local_nodeid();
 node_name | bdr_terminate_workers 
-----------+-----------------------
 node-pg   | t
(1 row)

-- We must remain with our own apply worker
SELECT COUNT(*) = 1 AS ok FROM bdr.bdr_get_workers_info()
  WHERE (sysid, timeline, dboid) = bdr.bdr_get_local_nodeid() AND worker_type = 'apply';
 ok 
----
 t
(1 row)

-- One worker should vanish and not have restarted because of the timer
SELECT wait_for_nworkers(1);
 wait_for_nworkers 
-------------------
 
(1 row)

-- Wait for reconnect. No need for bdr_connections_changed()
-- since this'll just stop the apply workers quitting as soon
-- as they launch.
BEGIN; SET LOCAL bdr.skip_ddl_replication = true; SELECT bdr._bdr_pause_worker_management_private(false); COMMIT;
 _bdr_pause_worker_management_private 
--------------------------------------
 
(1 row)

SELECT wait_for_nworkers(2);
 wait_for_nworkers 
-------------------
 
(1 row)

SELECT pg_sleep(10);
 pg_sleep 
----------
 
(1 row)

BEGIN; SET LOCAL bdr.skip_ddl_replication = true; SELECT bdr._bdr_pause_worker_management_private(true); COMMIT;
 _bdr_pause_worker_management_private 
--------------------------------------
 
(1 row)

-- We're one instance with two databases so we should have two walsender workers
SELECT COUNT(*) = 2 AS ok FROM bdr.bdr_get_workers_info() WHERE worker_type = 'walsender';
 ok 
----
 t
(1 row)

-- Kill all walsenders except our own
SELECT n.node_name, bdr.bdr_terminate_workers(node_sysid, node_timeline, node_dboid, 'walsender')
  FROM bdr.bdr_nodes n
  WHERE (node_sysid, node_timeline, node_dboid) <> bdr.bdr_get_local_nodeid();
 node_name | bdr_terminate_workers 
-----------+-----------------------
 node-pg   | t
(1 row)

SELECT pg_sleep(10);
 pg_sleep 
----------
 
(1 row)

-- We must remain with our own walsender
SELECT COUNT(*) = 1 AS ok FROM bdr.bdr_get_workers_info()
  WHERE (sysid, timeline, dboid) = bdr.bdr_get_local_nodeid() AND worker_type = 'walsender';
 ok 
----
 t
(1 row)

-- One left
SELECT wait_for_nwalsenders(1);
 wait_for_nwalsenders 
----------------------
 
(1 row)

-- OK, let them come back up
BEGIN; SET LOCAL bdr.skip_ddl_replication = true; SELECT bdr._bdr_pause_worker_management_private(false); COMMIT;
 _bdr_pause_worker_management_private 
--------------------------------------
 
(1 row)

SELECT wait_for_nwalsenders(2);
 wait_for_nwalsenders 
----------------------
 
(1 row)

