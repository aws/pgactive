  [BDR 2.0.7 Documentation](README.md)                                                                                                                    
  [Prev](global-sequence-usage.md "Using global sequences")   [Up](global-sequences.md)    Chapter 10. Global Sequences    [Next](global-sequences-orms.md "Global sequences and ORMs")  


# 10.4. Global sequence limitations

A few limitations and caveats apply to global sequences at time of
writing, in addition to those discussed in [when to use global
sequences](global-sequences-when.md):

There is no transparent remapping of local sequences to global
sequences. Schemas and/or applications must be modified to explicitly
call `bdr.global_seq_nextval(...)` or use it as a
`DEFAULT` for a column. (A future version may handle
`BIGSERIAL` automatically).

Global sequences are 64-bits wide and need a `bigint` or
`bigserial`. There is no 32-bit `integer` version.
Down-casting will not work.

`currval(...)` and `lastval()` return the value of
the underlying sequence, not the value generated by
`bdr.global_seq_nextval(...)`. Do not use them with global
sequences. This is a particular concern with ORMs; see [Global sequences
and ORMs](global-sequences-orms.md).

The `INCREMENT` option on a sequence used as input for global
sequences is effectively ignored. This could be relevant for
applications that do sequence ID caching, like many object-relational
mapper (ORM) tools, notably Hibernate. Because the sequence is
time-based this has little practical effect since the sequence will have
advanced to a new non-colliding value by the time the application can do
anything with the cached values.

There is a limit of 8192 sequence values generated per millisecond on
any given node for any given sequence. If more than 8192 sequences per
millisecond are generated from one sequence on one node, the generated
values will wrap around and collide. This will usually result in a
`UNIQUE` constraint violation on `INSERT` or
`UPDATE`. It cannot cause a replication conflict because
sequence values generated on different nodes can [*never*]
collide.

In practice this is harmless since values are not generated fast enough
to trigger this limitation. Generating a single ID typically takes over
3ns, so 8192 per ms is exceedingly unlikely especially since there will
be other work being done, rows inserted, indexes updated, etc. Despite
that, applications should have a `UNIQUE` constraint in place
where they absolutely rely on lack of collisions.

Similarly, the `MINVALUE`, `MAXVALUE` and
`CACHE` settings may be changed on the underlying sequence,
but there is no benefit to doing so. The sequence\'s low 14 bits are
used and the rest is discarded, so the value range limits don\'t affect
the function\'s result. For the same reason, `setval(...)` is
not useful for sequences used with
`bdr.global_sequence_nextval(..)`.

The `CACHE` directive may be used as normal. Because the
sequence is time-based there\'s no point trying to avoid \"unnecessary\"
sequence increments, though.



  --------------------------------------------------- -------------------------------------------- ---------------------------------------------------
  [Prev](global-sequence-usage.md)        [Home](README.md)         [Next](global-sequences-orms.md)  
  Using global sequences                               [Up](global-sequences.md)                            Global sequences and ORMs
  --------------------------------------------------- -------------------------------------------- ---------------------------------------------------
