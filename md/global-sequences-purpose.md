::: NAVHEADER
  [BDR 2.0.7 Documentation](index.md)
  ----------------------------------------------------------------- -------------------------------------------- ------------------------------ ----------------------------------------------------------------------------------
  [Prev](global-sequences.md "Global Sequences"){accesskey="P"}   [Up](global-sequences.md){accesskey="U"}    Chapter 10. Global Sequences    [Next](global-sequences-when.md "When to use global sequences"){accesskey="N"}

------------------------------------------------------------------------
:::

::: SECT1
# [10.1. Purpose of global sequences]{#GLOBAL-SEQUENCES-PURPOSE} {#purpose-of-global-sequences .SECT1}

Many applications require unique values be assigned to database entries.
Some applications use [UUID]{.APPLICATION}s/[GUID]{.APPLICATION}s
generated by external programs, some use database-supplied values. This
is important with optimistic conflict resolution schemes (like that in
BDR) because uniqueness violations can result in discarded inserts
during conflict resolution.

The SQL standard requires `SEQUENCE`{.LITERAL} objects which generate
unique values. These can then be used to supply default values using
`DEFAULT nextval('mysequence')`{.LITERAL}, as with PostgreSQL\'s
`SERIAL`{.LITERAL} pseudo-type. PostgreSQL doesn\'t provide any
facilities to synchronise or replicate sequences, so they\'re purely
node-local.

A typical approach for sharded or multi-node applications is to use
split-step or partitioned sequences, where all nodes increment the
sequence by the same fixed value and each node has a fixed offset within
the sequence. So node 1 generates IDs 1, 101, 201, 301, \...; node 2
generates IDs 2, 102, 202, 302, \...; etc. This is easily done with
PostgreSQL\'s existing sequences, but becomes a major problem if you
don\'t allow enough room for growth - in the above, if you have 101
nodes you\'re in serious trouble. It\'s also awkward, requiring
node-specific DDL and setup. It also makes replacing failed nodes
difficult as each table must be scanned to determine what ID each
sequence was up to on the node before failure, or a new (very finite)
node ID must be allocated. See [Section
10.7](global-sequences-alternatives.md).

To help avoid [Multi-master conflicts](conflicts.md) on concurrent
inserts BDR provides a global sequence mapping function. This allows a
normal sequence to be used in a globally-unique manner by qualifying its
result with a unique node ID and timestamp. See [Using global
sequences](global-sequence-usage.md).

BDR manages the node IDs internally (see [the
`bdr.bdr_nodes.node_seq_id`{.LITERAL} column](catalog-bdr-nodes.md)).
Node IDs for parted nodes are re-used, so node ID exhaustion is not a
concern for environments that regularly part and join nodes, such as for
load balancing.

::: NOTE
> **Note:** BDR 1.0 provided a different implementation of global
> sequences with different syntax and behaviour. See [BDR 1.0 Global
> Sequences](global-sequences-bdr10.md).
:::
:::

::: NAVFOOTER

------------------------------------------------------------------------

  ---------------------------------------------- -------------------------------------------- ---------------------------------------------------
  [Prev](global-sequences.md){accesskey="P"}        [Home](index.md){accesskey="H"}         [Next](global-sequences-when.md){accesskey="N"}
  Global Sequences                                [Up](global-sequences.md){accesskey="U"}                         When to use global sequences
  ---------------------------------------------- -------------------------------------------- ---------------------------------------------------
:::
